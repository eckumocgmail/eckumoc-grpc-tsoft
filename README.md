# eckumoc-grpc-tsoft
Приложение должно демонстрировать использование примитивов синхронизации доступа в многопоточной среде. 
Программист .Net 6/7/8, C#
Тестовое задание.

Net 6/7, C#.

Общая задача — показать в окне непрерывные перемещения прямоугольников. Каждый
прямоугольник движется под углом 45 градусов, отскакивает от стен и продолжает движение.
Количество прямоугольников — 1000 штук — задаётся константой.
Приложение для отображения: WPF или Avalonia UI, binding, MVVM. Code-behind не допускается.
Усложнение: это сетевое приложение с двух- или трёхзвенной архитектурой с обменом данными
по gRPC/Protobuf.

Сервер генерирует поток данных. Это консольное приложение.
На сервере есть хранилище — список или массив, содержащее данные K прямоугольников.
K — это константа порядка 100..500..1000..2000 (по умолчанию — 1000 штук).
На сервере работают N задач/потоков, которые пытаются одновременно менять данные в
хранилище (задачи «перемещают» прямоугольники, контролируют отскоки и т.п.).
N — это константа порядка 5..10..20..50 (по умолчанию - 20).
В процессе работы координаты прямоугольников плавно меняются от случайных стартовых в
случайную на старте сторону в рамках заданных координат и размеров (аналогия - скринсейвер в
виде плавающего квадрата в старых видеомагнитофонах/DVD и т. п; bouncing balls).
Координаты передаются клиенту по gRPC/Protobuf непрерывно с момента запроса от клиента.
Здесь основная задача - показать использование многозадачности/многопоточности с
применением объектов синхронизации (lock, Semaphore и т. п.).

Клиент принимает данные и отображает их в окне в виде плавающих прямоугольников.
Прямоугольник создаётся на клиенте, если такого прямоугольника ещё нет у клиента.

Дополнительно:
Для сетевого взаимодействия очень желательно использовать gRPC + Protobuf, но можно
применить и свой протокол на базе UDP. Не нужно использовать WCF.
Размеры поля, внутри которого перемещаются прямоугольники — общие константы для клиента и
сервера.
Результат в виде решения MS VS 2022 залить на github (приватный или нет – за разработчиком).
Репозиторий должен содержать простой ReadMe с указаниями по сборке.
Решение должно содержать проекты сервера и клиента. В случае использования gRPC –
отдельный проект со структурами Protobuf.
